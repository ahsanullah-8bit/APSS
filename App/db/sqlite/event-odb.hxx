// -*- C++ -*-
//
// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#ifndef EVENT_ODB_HXX
#define EVENT_ODB_HXX

// Begin prologue.
//
#include <odb/qt/version.hxx>
#if ODB_QT_VERSION != 2050000 // 2.5.0
#  error ODB and C++ compilers see different libodb-qt interface versions
#endif
#include <odb/qt/basic/sqlite/qstring-traits.hxx>
#include <odb/qt/basic/sqlite/qbyte-array-traits.hxx>
#include <odb/qt/basic/sqlite/quuid-traits.hxx>
#include <odb/qt/containers/qhash-traits.hxx>
#include <odb/qt/containers/qlist-traits.hxx>
#include <odb/qt/containers/qlinked-list-traits.hxx>
#include <odb/qt/containers/qmap-traits.hxx>
#include <odb/qt/containers/qset-traits.hxx>
#include <odb/qt/containers/qvector-traits.hxx>
#include <odb/qt/date-time/sqlite/qdate-traits.hxx>
#include <odb/qt/date-time/sqlite/qtime-traits.hxx>
#include <odb/qt/date-time/sqlite/qdate-time-traits.hxx>
#include <QtCore/QSharedPointer>
#include <odb/qt/smart-ptr/pointer-traits.hxx>
#include <odb/qt/smart-ptr/wrapper-traits.hxx>
//
// End prologue.

#include <odb/version.hxx>

#if ODB_VERSION != 20500UL
#error ODB runtime version mismatch
#endif

#include <odb/pre.hxx>

#include "event.h"

#include <memory>
#include <cstddef>
#include <utility>

#include <odb/core.hxx>
#include <odb/traits.hxx>
#include <odb/callback.hxx>
#include <odb/wrapper-traits.hxx>
#include <odb/pointer-traits.hxx>
#include <odb/container-traits.hxx>
#include <odb/no-op-cache-traits.hxx>
#include <odb/result.hxx>
#include <odb/simple-object-result.hxx>

#include <odb/details/unused.hxx>
#include <odb/details/shared-ptr.hxx>

namespace odb
{
  // Event
  //
  template <>
  struct class_traits< ::Event >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Event >
  {
    public:
    typedef ::Event object_type;
    typedef ::QSharedPointer< ::Event > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::QString id_type;

    static const bool auto_id = false;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };
}

#include <odb/details/buffer.hxx>

#include <odb/sqlite/version.hxx>
#include <odb/sqlite/forward.hxx>
#include <odb/sqlite/binding.hxx>
#include <odb/sqlite/sqlite-types.hxx>
#include <odb/sqlite/query.hxx>

namespace odb
{
  // Event
  //
  template <typename A>
  struct query_columns< ::Event, id_sqlite, A >
  {
    // id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    id_type_;

    static const id_type_ id;

    // label
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    label_type_;

    static const label_type_ label;

    // subLabel
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    subLabel_type_;

    static const subLabel_type_ subLabel;

    // camera
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    camera_type_;

    static const camera_type_ camera;

    // startTime
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QDateTime,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    startTime_type_;

    static const startTime_type_ startTime;

    // endTime
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QDateTime,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    endTime_type_;

    static const endTime_type_ endTime;

    // trackerId
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    trackerId_type_;

    static const trackerId_type_ trackerId;

    // topScore
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        float,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    topScore_type_;

    static const topScore_type_ topScore;

    // score
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        float,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    score_type_;

    static const score_type_ score;

    // falsePositive
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        bool,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    falsePositive_type_;

    static const falsePositive_type_ falsePositive;

    // zones
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    zones_type_;

    static const zones_type_ zones;

    // thumbnail
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    thumbnail_type_;

    static const thumbnail_type_ thumbnail;

    // hasClip
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        bool,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hasClip_type_;

    static const hasClip_type_ hasClip;

    // hasSnapshot
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        bool,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hasSnapshot_type_;

    static const hasSnapshot_type_ hasSnapshot;

    // region
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    region_type_;

    static const region_type_ region;

    // box
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    box_type_;

    static const box_type_ box;

    // area
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    area_type_;

    static const area_type_ area;

    // retainIndefinitely
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        bool,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    retainIndefinitely_type_;

    static const retainIndefinitely_type_ retainIndefinitely;

    // ratio
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        float,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    ratio_type_;

    static const ratio_type_ ratio;

    // plusId
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    plusId_type_;

    static const plusId_type_ plusId;

    // modelHash
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    modelHash_type_;

    static const modelHash_type_ modelHash;

    // detectorType
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    detectorType_type_;

    static const detectorType_type_ detectorType;

    // modelType
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    modelType_type_;

    static const modelType_type_ modelType;

    // data
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::QString,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    data_type_;

    static const data_type_ data;
  };

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::id_type_
  query_columns< ::Event, id_sqlite, A >::
  id (A::table_name, "\"id\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::label_type_
  query_columns< ::Event, id_sqlite, A >::
  label (A::table_name, "\"label\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::subLabel_type_
  query_columns< ::Event, id_sqlite, A >::
  subLabel (A::table_name, "\"subLabel\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::camera_type_
  query_columns< ::Event, id_sqlite, A >::
  camera (A::table_name, "\"camera\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::startTime_type_
  query_columns< ::Event, id_sqlite, A >::
  startTime (A::table_name, "\"startTime\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::endTime_type_
  query_columns< ::Event, id_sqlite, A >::
  endTime (A::table_name, "\"endTime\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::trackerId_type_
  query_columns< ::Event, id_sqlite, A >::
  trackerId (A::table_name, "\"trackerId\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::topScore_type_
  query_columns< ::Event, id_sqlite, A >::
  topScore (A::table_name, "\"topScore\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::score_type_
  query_columns< ::Event, id_sqlite, A >::
  score (A::table_name, "\"score\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::falsePositive_type_
  query_columns< ::Event, id_sqlite, A >::
  falsePositive (A::table_name, "\"falsePositive\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::zones_type_
  query_columns< ::Event, id_sqlite, A >::
  zones (A::table_name, "\"zones\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::thumbnail_type_
  query_columns< ::Event, id_sqlite, A >::
  thumbnail (A::table_name, "\"thumbnail\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::hasClip_type_
  query_columns< ::Event, id_sqlite, A >::
  hasClip (A::table_name, "\"hasClip\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::hasSnapshot_type_
  query_columns< ::Event, id_sqlite, A >::
  hasSnapshot (A::table_name, "\"hasSnapshot\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::region_type_
  query_columns< ::Event, id_sqlite, A >::
  region (A::table_name, "\"region\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::box_type_
  query_columns< ::Event, id_sqlite, A >::
  box (A::table_name, "\"box\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::area_type_
  query_columns< ::Event, id_sqlite, A >::
  area (A::table_name, "\"area\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::retainIndefinitely_type_
  query_columns< ::Event, id_sqlite, A >::
  retainIndefinitely (A::table_name, "\"retainIndefinitely\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::ratio_type_
  query_columns< ::Event, id_sqlite, A >::
  ratio (A::table_name, "\"ratio\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::plusId_type_
  query_columns< ::Event, id_sqlite, A >::
  plusId (A::table_name, "\"plusId\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::modelHash_type_
  query_columns< ::Event, id_sqlite, A >::
  modelHash (A::table_name, "\"modelHash\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::detectorType_type_
  query_columns< ::Event, id_sqlite, A >::
  detectorType (A::table_name, "\"detectorType\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::modelType_type_
  query_columns< ::Event, id_sqlite, A >::
  modelType (A::table_name, "\"modelType\"", 0);

  template <typename A>
  const typename query_columns< ::Event, id_sqlite, A >::data_type_
  query_columns< ::Event, id_sqlite, A >::
  data (A::table_name, "\"data\"", 0);

  template <typename A>
  struct pointer_query_columns< ::Event, id_sqlite, A >:
    query_columns< ::Event, id_sqlite, A >
  {
  };

  template <>
  class access::object_traits_impl< ::Event, id_sqlite >:
    public access::object_traits< ::Event >
  {
    public:
    struct id_image_type
    {
      details::buffer id_value;
      std::size_t id_size;
      bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // m_id
      //
      details::buffer m_id_value;
      std::size_t m_id_size;
      bool m_id_null;

      // m_label
      //
      details::buffer m_label_value;
      std::size_t m_label_size;
      bool m_label_null;

      // m_subLabel
      //
      details::buffer m_subLabel_value;
      std::size_t m_subLabel_size;
      bool m_subLabel_null;

      // m_camera
      //
      details::buffer m_camera_value;
      std::size_t m_camera_size;
      bool m_camera_null;

      // m_startTime
      //
      details::buffer m_startTime_value;
      std::size_t m_startTime_size;
      bool m_startTime_null;

      // m_endTime
      //
      details::buffer m_endTime_value;
      std::size_t m_endTime_size;
      bool m_endTime_null;

      // m_trackerId
      //
      long long m_trackerId_value;
      bool m_trackerId_null;

      // m_topScore
      //
      double m_topScore_value;
      bool m_topScore_null;

      // m_score
      //
      double m_score_value;
      bool m_score_null;

      // m_falsePositive
      //
      long long m_falsePositive_value;
      bool m_falsePositive_null;

      // m_zones
      //
      details::buffer m_zones_value;
      std::size_t m_zones_size;
      bool m_zones_null;

      // m_thumbnail
      //
      details::buffer m_thumbnail_value;
      std::size_t m_thumbnail_size;
      bool m_thumbnail_null;

      // m_hasClip
      //
      long long m_hasClip_value;
      bool m_hasClip_null;

      // m_hasSnapshot
      //
      long long m_hasSnapshot_value;
      bool m_hasSnapshot_null;

      // m_region
      //
      details::buffer m_region_value;
      std::size_t m_region_size;
      bool m_region_null;

      // m_box
      //
      details::buffer m_box_value;
      std::size_t m_box_size;
      bool m_box_null;

      // m_area
      //
      long long m_area_value;
      bool m_area_null;

      // m_retainIndefinitely
      //
      long long m_retainIndefinitely_value;
      bool m_retainIndefinitely_null;

      // m_ratio
      //
      double m_ratio_value;
      bool m_ratio_null;

      // m_plusId
      //
      details::buffer m_plusId_value;
      std::size_t m_plusId_size;
      bool m_plusId_null;

      // m_modelHash
      //
      details::buffer m_modelHash_value;
      std::size_t m_modelHash_size;
      bool m_modelHash_null;

      // m_detectorType
      //
      details::buffer m_detectorType_value;
      std::size_t m_detectorType_size;
      bool m_detectorType_null;

      // m_modelType
      //
      details::buffer m_modelType_value;
      std::size_t m_modelType_size;
      bool m_modelType_null;

      // m_data
      //
      details::buffer m_data_value;
      std::size_t m_data_size;
      bool m_data_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          sqlite::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query_base query_base_type;

    static const std::size_t column_count = 24UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::Event, id_common >:
    public access::object_traits_impl< ::Event, id_sqlite >
  {
  };

  // Event
  //
}

#include "event-odb.ixx"

#include <odb/post.hxx>

#endif // EVENT_ODB_HXX
